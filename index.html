<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ‘çš„3Dç…§ç‰‡åœ£è¯æ ‘</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif;}
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            pointer-events: auto;
            user-select: none;
        }
        input[type=file] { display: none; }
        .upload-btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: #c41e3a;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            transition: background 0.3s;
        }
        .upload-btn:hover { background-color: #e62e4d; }
        #instructions { margin-top: 10px; font-size: 0.9em; color: #ccc; }

        #image-modal {
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.9); 
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #modal-content {
            max-width: 90%;
            max-height: 80%;
            border: 5px solid white;
            box-shadow: 0 0 20px yellow;
        }
        #close-modal {
            margin-top: 20px;
            padding: 10px 30px;
            background: white;
            color: black;
            border: none;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-container">
        <label for="file-input" class="upload-btn">ğŸ“· ä¸Šä¼ ç…§ç‰‡è£…é¥°</label>
        <input type="file" id="file-input" accept="image/png, image/jpeg, image/jpg" multiple>
        <div id="instructions">
            <p>1. é¢„è®¾ç…§ç‰‡åŠ è½½ä¸­...</p>
            <p>2. ç‚¹å‡»æŒ‰é’®å¯æ‰‹åŠ¨æŒ‚æ›´å¤šç…§ç‰‡ã€‚</p>
            <p>3. é¼ æ ‡æ‹–åŠ¨æ—‹è½¬ï¼Œæ»šè½®ç¼©æ”¾ã€‚</p>
            <p>4. <b>ç‚¹å‡»æ ‘ä¸Šçš„ç…§ç‰‡</b>å¯ä»¥æ”¾å¤§æŸ¥çœ‹ã€‚</p>
        </div>
    </div>

    <div id="image-modal">
        <img id="modal-content" src="">
        <button id="close-modal">å…³é—­é¢„è§ˆ</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==========================================
        // ğŸ‘‡ğŸ‘‡ğŸ‘‡ åœ¨è¿™é‡Œä¿®æ”¹ä½ çš„å›¾ç‰‡æ–‡ä»¶å ğŸ‘‡ğŸ‘‡ğŸ‘‡
        // æ ¼å¼æ³¨æ„ï¼š['1.jpg', '2.jpg'] (æ³¨æ„è‹±æ–‡å¼•å·å’Œé€—å·)
        // è¿™é‡Œçš„åå­—å¿…é¡»å’Œä½ ä¸Šä¼ åˆ° GitHub çš„å®Œå…¨ä¸€è‡´ï¼
        const myImages = [
           'image_0dc58f.png'  // è¿™é‡Œæˆ‘å·²ç»å¸®ä½ å¡«ä¸Šäº†ä½ åˆšæ‰æˆªå›¾é‡Œçš„é‚£ä¸ªæ–‡ä»¶å
        ];
        // ==========================================

        let scene, camera, renderer, controls;
        let treeGroup;
        let ornaments = []; 
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const ornamentPositions = [];

        try {
            init();
            animate();
        } catch (error) {
            console.error("ç¨‹åºå¯åŠ¨å¤±è´¥:", error);
            alert("ç¨‹åºå¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°(F12)è·å–è¯¦ç»†ä¿¡æ¯");
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            scene.background = new THREE.Color(0x110011);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 35);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 + 0.1; 
            controls.minDistance = 10;
            controls.maxDistance = 60;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffd700, 1.5, 100);
            pointLight.position.set(10, 20, 10);
            pointLight.castShadow = true;
            scene.add(pointLight);

            createEnvironment();
            createTree();
            
            // å»¶è¿Ÿä¸€ç‚¹ç‚¹åŠ è½½å›¾ç‰‡ï¼Œç¡®ä¿åœºæ™¯å‡†å¤‡å¥½
            setTimeout(loadPresetImages, 500);

            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            renderer.domElement.addEventListener('click', onMouseClick);
            document.getElementById('close-modal').addEventListener('click', closeModal);
        }

        function createEnvironment() {
            const planeGeometry = new THREE.PlaneGeometry(200, 200);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xddddff, roughness: 1 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -1;
            plane.receiveShadow = true;
            scene.add(plane);

            const particleCount = 1000;
            const particlesGeometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(particleCount * 3);
            for(let i=0; i<particleCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 100;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.2, 
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const snow = new THREE.Points(particlesGeometry, particlesMaterial);
            snow.position.y = 20;
            
            snow.userData.update = function() {
                const positions = this.geometry.attributes.position.array;
                for(let i = 1; i < positions.length; i+=3) {
                    positions[i] -= 0.1;
                    if (positions[i] < -1) positions[i] = 50;
                }
                this.geometry.attributes.position.needsUpdate = true;
            }
            scene.add(snow);
        }

        function createTree() {
            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            const trunkGeometry = new THREE.CylinderGeometry(1.5, 2, 6, 12);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x4d2600, roughness: 0.8 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x0f5f13, roughness: 0.6, flatShading: true });
            
            const levels = [
                { height: 8, radius: 8, yPos: 7, positionsCount: 8 }, 
                { height: 7, radius: 6, yPos: 12, positionsCount: 6 }, 
                { height: 6, radius: 4, yPos: 16.5, positionsCount: 4 } 
            ];

            levels.forEach((level, index) => {
                const coneGeo = new THREE.ConeGeometry(level.radius, level.height, 16);
                const cone = new THREE.Mesh(coneGeo, leafMaterial);
                cone.position.y = level.yPos;
                cone.castShadow = true;
                treeGroup.add(cone);

                for (let i = 0; i < level.positionsCount; i++) {
                    const angle = (i / level.positionsCount) * Math.PI * 2;
                    const r = level.radius * 0.85; 
                    const x = Math.cos(angle) * r;
                    const y = level.yPos - level.height * 0.25; 
                    const z = Math.sin(angle) * r;
                    ornamentPositions.push({pos: new THREE.Vector3(x, y, z), angle: angle});
                }
            });

            const starGeo = new THREE.OctahedronGeometry(1.5, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffea00 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = 20;
            treeGroup.add(star);

            const starLight = new THREE.PointLight(0xffea00, 1, 20);
            starLight.position.set(0, 20.5, 0);
            treeGroup.add(starLight);
        }

        function loadPresetImages() {
            const textureLoader = new THREE.TextureLoader();
            console.log("å¼€å§‹åŠ è½½é¢„è®¾å›¾ç‰‡...", myImages);

            myImages.forEach((imageName) => {
                if (ornaments.length >= ornamentPositions.length) return;

                textureLoader.load(
                    imageName, 
                    (texture) => {
                        console.log("å›¾ç‰‡åŠ è½½æˆåŠŸ:", imageName);
                        createPhotoFrame(texture, imageName);
                    },
                    undefined, // onProgress
                    (err) => {
                        console.error("âŒ å›¾ç‰‡åŠ è½½å¤±è´¥:", imageName, err);
                    }
                );
            });
        }

        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files.length) return;
            const textureLoader = new THREE.TextureLoader();

            Array.from(files).forEach(file => {
                if (ornaments.length >= ornamentPositions.length) {
                    alert("æ ‘ä¸ŠæŒ‚æ»¡å•¦ï¼");
                    return;
                }
                const reader = new FileReader();
                reader.onload = function(e) {
                    textureLoader.load(e.target.result, (texture) => {
                        createPhotoFrame(texture, e.target.result);
                    });
                };
                reader.readAsDataURL(file);
            });
            event.target.value = '';
        }

        function createPhotoFrame(texture, imageUri) {
            texture.colorSpace = THREE.SRGBColorSpace;
            // ä¿®æ­£ï¼šç¡®ä¿çº¹ç†å®Œæ•´åŠ è½½åå†è·å–å°ºå¯¸
            const img = texture.image;
            let aspect = 1;
            if (img.width && img.height) {
                aspect = img.width / img.height;
            }

            // é™åˆ¶æœ€å¤§å®½é«˜ï¼Œä¿æŒæ¯”ä¾‹
            let planeWidth = 2.5;
            let planeHeight = 2.5;
            if (aspect > 1) {
                planeHeight = planeWidth / aspect;
            } else {
                planeWidth = planeHeight * aspect;
            }

            const frameGroup = new THREE.Group();

            const photoGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const photoMaterial = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const photoMesh = new THREE.Mesh(photoGeometry, photoMaterial);
            photoMesh.position.z = 0.05; 
            photoMesh.userData = { isPhoto: true, imageUri: imageUri };
            
            const borderGeometry = new THREE.PlaneGeometry(planeWidth + 0.2, planeHeight + 0.2);
            const borderMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
            const borderMesh = new THREE.Mesh(borderGeometry, borderMaterial);

            frameGroup.add(borderMesh);
            frameGroup.add(photoMesh);

            const posData = ornamentPositions[ornaments.length];
            frameGroup.position.copy(posData.pos);
            
            frameGroup.rotation.y = -posData.angle + Math.PI / 2;
            frameGroup.rotation.x = (Math.random() - 0.5) * 0.3;
            frameGroup.rotation.z = (Math.random() - 0.5) * 0.3;

            treeGroup.add(frameGroup);
            ornaments.push(photoMesh); 
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(ornaments);
            if (intersects.length > 0) {
                const selectedObject = intersects[0].object;
                if (selectedObject.userData.isPhoto) {
                    openModal(selectedObject.userData.imageUri);
                }
            }
        }

        function openModal(imageUri) {
            const modal = document.getElementById('image-modal');
            const modalImg = document.getElementById('modal-content');
            modalImg.src = imageUri;
            modal.style.display = 'flex';
        }

        function closeModal() {
             document.getElementById('image-modal').style.display = 'none';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (treeGroup) treeGroup.rotation.y += 0.002;
            scene.traverse((child) => {
                if (child.userData.update) child.userData.update();
            });
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
