<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ‘çš„3Dç…§ç‰‡åœ£è¯æ ‘</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif;}
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        /* UI ç•Œé¢æ ·å¼ */
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            pointer-events: auto;
        }
        input[type=file] { display: none; }
        .upload-btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: #c41e3a;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            transition: background 0.3s;
        }
        .upload-btn:hover { background-color: #e62e4d; }
        #instructions { margin-top: 10px; font-size: 0.9em; color: #ccc; }

        /* å›¾ç‰‡é¢„è§ˆæ¨¡æ€æ¡†æ ·å¼ */
        #image-modal {
            display: none; /* é»˜è®¤éšè— */
            position: fixed; 
            z-index: 100; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.9); 
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #modal-content {
            max-width: 90%;
            max-height: 80%;
            border: 5px solid white;
            box-shadow: 0 0 20px yellow;
        }
        #close-modal {
            margin-top: 20px;
            padding: 10px 30px;
            background: white;
            color: black;
            border: none;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-container">
        <label for="file-input" class="upload-btn">ğŸ“· ä¸Šä¼ ç…§ç‰‡è£…é¥°åœ£è¯æ ‘</label>
        <input type="file" id="file-input" accept="image/png, image/jpeg, image/jpg" multiple>
        <div id="instructions">
            <p>1. ç‚¹å‡»æŒ‰é’®ä¸Šä¼ æœ¬åœ°å›¾ç‰‡ (æ”¯æŒå¤šé€‰)ã€‚</p>
            <p>2. å›¾ç‰‡ä¼šè‡ªåŠ¨æŒ‚åˆ°æ ‘ä¸Šã€‚</p>
            <p>3. é¼ æ ‡æ‹–åŠ¨æ—‹è½¬ï¼Œæ»šè½®ç¼©æ”¾ã€‚</p>
            <p>4. <b>ç‚¹å‡»æ ‘ä¸Šçš„ç…§ç‰‡</b>å¯ä»¥æ”¾å¤§æŸ¥çœ‹ã€‚</p>
        </div>
    </div>

    <div id="image-modal">
        <img id="modal-content" src="">
        <button id="close-modal">å…³é—­é¢„è§ˆ</button>
    </div>


    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let scene, camera, renderer, controls;
        let treeGroup;
        let ornaments = []; // å­˜æ”¾ç…§ç‰‡è£…é¥°ç‰©çš„æ•°ç»„
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // é¢„å®šä¹‰æ ‘ä¸Šå¯ä»¥æŒ‚ç…§ç‰‡çš„ä½ç½® (ç›¸å¯¹äºæ ‘ä¸­å¿ƒ)
        // æ ¼å¼: [x, y, z, æ‰€åœ¨çš„å±‚çº§ç´¢å¼•]
        const ornamentPositions = [];

        init();
        animate();

        function init() {
            // 1. åœºæ™¯è®¾ç½®
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            scene.background = new THREE.Color(0x110011); // æ·±å¤œèƒŒæ™¯

            // 2. ç›¸æœºè®¾ç½®
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 35);

            // 3. æ¸²æŸ“å™¨è®¾ç½®
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. æ§åˆ¶å™¨ (å…è®¸é¼ æ ‡æ—‹è½¬ç¼©æ”¾)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 + 0.1; // é˜²æ­¢è§†è§’é’»åˆ°åœ°åº•ä¸‹å¤ªæ·±
            controls.minDistance = 10;
            controls.maxDistance = 60;

            // 5. ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffd700, 1.5, 100);
            pointLight.position.set(10, 20, 10);
            pointLight.castShadow = true;
            scene.add(pointLight);

            // 6. åˆ›å»ºç¯å¢ƒå’Œæ ‘
            createEnvironment();
            createTree();

            // 7. äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            renderer.domElement.addEventListener('click', onMouseClick);
            document.getElementById('close-modal').addEventListener('click', closeModal);
        }

        // åˆ›å»ºåœ°é¢å’Œé›ªèŠ±
        function createEnvironment() {
             // åœ°é¢
            const planeGeometry = new THREE.PlaneGeometry(200, 200);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xddddff, roughness: 1 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -1;
            plane.receiveShadow = true;
            scene.add(plane);

            // ç®€å•çš„ç²’å­é›ªèŠ±
            const particleCount = 1000;
            const particlesGeometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(particleCount * 3);
            for(let i=0; i<particleCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 100;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.2, 
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            const snow = new THREE.Points(particlesGeometry, particlesMaterial);
            snow.position.y = 20;
            scene.add(snow);
            
            // è®©é›ªèŠ±åŠ¨èµ·æ¥çš„ç®€å•é€»è¾‘æŒ‚è½½åˆ°å¯¹è±¡ä¸Š
            snow.userData.update = function() {
                const positions = this.geometry.attributes.position.array;
                for(let i = 1; i < positions.length; i+=3) {
                    positions[i] -= 0.1;
                    if (positions[i] < -1) positions[i] = 50;
                }
                this.geometry.attributes.position.needsUpdate = true;
            }
            scene.add(snow);
        }

        // åˆ›å»ºåœ£è¯æ ‘ä¸»ä½“
        function createTree() {
            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            // æ ‘å¹²
            const trunkGeometry = new THREE.CylinderGeometry(1.5, 2, 6, 12);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x4d2600, roughness: 0.8 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // æ ‘å¶ (ç”±ä¸‰ä¸ªåœ†é”¥ä½“å †å è€Œæˆ)
            const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x0f5f13, roughness: 0.6, flatShading: true });
            
            const levels = [
                { height: 8, radius: 8, yPos: 7, positionsCount: 8 }, // åº•å±‚
                { height: 7, radius: 6, yPos: 12, positionsCount: 6 }, // ä¸­å±‚
                { height: 6, radius: 4, yPos: 16.5, positionsCount: 4 } // é¡¶å±‚
            ];

            levels.forEach((level, index) => {
                const coneGeo = new THREE.ConeGeometry(level.radius, level.height, 16);
                const cone = new THREE.Mesh(coneGeo, leafMaterial);
                cone.position.y = level.yPos;
                cone.castShadow = true;
                treeGroup.add(cone);

                // è®¡ç®—æŒ‚ç…§ç‰‡çš„é¢„è®¾ä½ç½®
                for (let i = 0; i < level.positionsCount; i++) {
                    const angle = (i / level.positionsCount) * Math.PI * 2;
                    // åŠå¾„ç¨å¾®ç¼©å°ä¸€ç‚¹ï¼Œè®©ç…§ç‰‡è´´åœ¨æ ‘è¡¨é¢
                    const r = level.radius * 0.85; 
                    const x = Math.cos(angle) * r;
                    // yä½ç½®åœ¨åœ†é”¥ä½“çš„ä¸­ä¸‹éƒ¨
                    const y = level.yPos - level.height * 0.25; 
                    const z = Math.sin(angle) * r;
                    ornamentPositions.push({pos: new THREE.Vector3(x, y, z), angle: angle});
                }
            });

            // æ ‘é¡¶æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(1.5, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffea00 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = 20;
            treeGroup.add(star);

            // ç»™æ˜Ÿæ˜Ÿæ·»åŠ ä¸€ç‚¹å‘å…‰æ•ˆæœ
            const starLight = new THREE.PointLight(0xffea00, 1, 20);
            starLight.position.set(0, 20.5, 0);
            treeGroup.add(starLight);
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files.length) return;

            const textureLoader = new THREE.TextureLoader();

            Array.from(files).forEach(file => {
                // ç®€å•çš„æ£€æŸ¥æ˜¯å¦è¿˜æœ‰ç©ºä½
                if (ornaments.length >= ornamentPositions.length) {
                    alert("æ ‘ä¸ŠæŒ‚æ»¡å•¦ï¼");
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    const imgDataUri = e.target.result;
                    
                    // åŠ è½½å›¾ç‰‡çº¹ç†
                    textureLoader.load(imgDataUri, (texture) => {
                        // ä¿æŒå›¾ç‰‡æ¯”ä¾‹ï¼Œä½¿å…¶é€‚åº”æ­£æ–¹å½¢ç›¸æ¡†ï¼Œé¿å…æ‹‰ä¼¸
                        texture.colorSpace = THREE.SRGBColorSpace;
                        const aspect = texture.image.width / texture.image.height;
                        let planeWidth = 2.5;
                        let planeHeight = 2.5;

                        // åˆ›å»ºç…§ç‰‡çš„å‡ ä½•ä½“ (ç›¸æ¡†)
                        // æ·»åŠ ä¸€ä¸ªç™½è‰²çš„è¾¹æ¡†èƒŒæ™¯
                        const frameGroup = new THREE.Group();

                        // ç…§ç‰‡æœ¬èº«
                        const photoGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                        const photoMaterial = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                        const photoMesh = new THREE.Mesh(photoGeometry, photoMaterial);
                        photoMesh.position.z = 0.05; // ç¨å¾®çªå‡ºä¸€ç‚¹
                        // ä¿å­˜åŸå§‹å¤§å›¾çš„ URI ç”¨äºç‚¹å‡»é¢„è§ˆ
                        photoMesh.userData = { isPhoto: true, imageUri: imgDataUri };
                        
                        // è¾¹æ¡†
                        const borderGeometry = new THREE.PlaneGeometry(planeWidth + 0.2, planeHeight + 0.2);
                        const borderMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
                        const borderMesh = new THREE.Mesh(borderGeometry, borderMaterial);

                        frameGroup.add(borderMesh);
                        frameGroup.add(photoMesh);

                        // è·å–ä¸‹ä¸€ä¸ªå¯ç”¨çš„ä½ç½®
                        const posData = ornamentPositions[ornaments.length];
                        frameGroup.position.copy(posData.pos);
                        
                        // è®©ç…§ç‰‡é¢å‘å¤–ä¾§
                        frameGroup.rotation.y = -posData.angle + Math.PI / 2;
                        
                        // æ·»åŠ ä¸€ç‚¹éšæœºå€¾æ–œï¼Œçœ‹èµ·æ¥æ›´è‡ªç„¶
                        frameGroup.rotation.x = (Math.random() - 0.5) * 0.3;
                        frameGroup.rotation.z = (Math.random() - 0.5) * 0.3;

                        treeGroup.add(frameGroup);
                        // æˆ‘ä»¬åªéœ€è¦æ£€æµ‹ photoMesh çš„ç‚¹å‡»ï¼Œæ‰€ä»¥åªæŠŠ photoMesh åŠ å…¥æ£€æµ‹æ•°ç»„
                        ornaments.push(photoMesh); 
                    });
                };
                reader.readAsDataURL(file);
            });
            // æ¸…ç©º inputï¼Œå…è®¸é‡å¤ä¸Šä¼ åŒä¸€å¼ å›¾
            event.target.value = '';
        }

        // å¤„ç†é¼ æ ‡ç‚¹å‡»äº‹ä»¶ (Raycasting)
        function onMouseClick(event) {
            // è®¡ç®—é¼ æ ‡åœ¨æ ‡å‡†è®¾å¤‡åæ ‡ä¸­çš„ä½ç½® (-1 åˆ° +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            // é€šè¿‡æ‘„åƒæœºå’Œé¼ æ ‡ä½ç½®æ›´æ–°å°„çº¿
            raycaster.setFromCamera(mouse, camera);

            // è®¡ç®—ç‰©ä½“å’Œå°„çº¿çš„ç„¦ç‚¹
            const intersects = raycaster.intersectObjects(ornaments);

            if (intersects.length > 0) {
                // è·å–ç¬¬ä¸€ä¸ªé€‰ä¸­çš„ç‰©ä½“
                const selectedObject = intersects[0].object;
                if (selectedObject.userData.isPhoto) {
                    openModal(selectedObject.userData.imageUri);
                }
            }
        }

        // æ‰“å¼€æ¨¡æ€æ¡†
        function openModal(imageUri) {
            const modal = document.getElementById('image-modal');
            const modalImg = document.getElementById('modal-content');
            modalImg.src = imageUri;
            modal.style.display = 'flex';
        }

        // å…³é—­æ¨¡æ€æ¡†
        function closeModal() {
             document.getElementById('image-modal').style.display = 'none';
        }


        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            // è®©æ•´ä¸ªæ ‘ç¼“æ…¢è‡ªè½¬
            if (treeGroup) {
                treeGroup.rotation.y += 0.002;
            }

            // æ›´æ–°é›ªèŠ±åŠ¨ç”»
            scene.traverse((child) => {
                if (child.userData.update) {
                    child.userData.update();
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>