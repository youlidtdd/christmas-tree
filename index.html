<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æˆ‘çš„3Dç…§ç‰‡åœ£è¯æ ‘</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif;}
        #canvas-container { width: 100%; height: 100vh; display: block; }
        
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            pointer-events: auto;
            user-select: none;
            max-width: 300px;
        }
        input[type=file] { display: none; }
        .upload-btn {
            display: inline-block;
            padding: 10px 20px;
            background-color: #c41e3a;
            color: white;
            cursor: pointer;
            border-radius: 5px;
            font-weight: bold;
            transition: background 0.3s;
        }
        .upload-btn:hover { background-color: #e62e4d; }
        #instructions { margin-top: 10px; font-size: 0.9em; color: #ccc; }

        #image-modal {
            display: none; 
            position: fixed; 
            z-index: 100; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.9); 
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }
        #modal-content {
            max-width: 90%;
            max-height: 80%;
            border: 5px solid white;
            box-shadow: 0 0 20px yellow;
        }
        #close-modal {
            margin-top: 20px;
            padding: 10px 30px;
            background: white;
            color: black;
            border: none;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-container">
        <label for="file-input" class="upload-btn">ğŸ“· ä¸Šä¼ ç…§ç‰‡æŒ‚ä¸Šå»</label>
        <input type="file" id="file-input" accept="image/png, image/jpeg, image/jpg" multiple>
        <div id="instructions">
            <p>1. å¦‚æœä½ æœ‰å›¾ç‰‡åœ¨GitHubé‡Œï¼Œè¯·ä¿®æ”¹ä»£ç é‡Œçš„ myImages åˆ—è¡¨ã€‚</p>
            <p>2. æˆ–è€…ç‚¹å‡»çº¢è‰²æŒ‰é’®ç›´æ¥ä¸Šä¼ ã€‚</p>
            <p>3. <b>ç‚¹å‡»æ ‘ä¸Šçš„ç…§ç‰‡</b>å¯ä»¥æ”¾å¤§æŸ¥çœ‹ã€‚</p>
        </div>
    </div>

    <div id="image-modal">
        <img id="modal-content" src="">
        <button id="close-modal">å…³é—­é¢„è§ˆ</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==========================================
        // ğŸ‘‡ ä¿®æ”¹è¿™é‡Œï¼š
        // æˆ‘å…ˆæŠŠå®ƒæ¸…ç©ºäº†ï¼Œé˜²æ­¢404æŠ¥é”™ã€‚
        // ç­‰ä½ ç¡®å®šæ–‡ä»¶ååï¼Œå†æŠŠåå­—å¡«è¿›å»ï¼Œä¾‹å¦‚: ['1.jpg', '2.jpg']
        const myImages = []; 
        // ==========================================

        let scene, camera, renderer, controls;
        let treeGroup;
        let snowSystem; // ä¸“é—¨çš„å˜é‡å­˜é›ªèŠ±
        let ornaments = []; 
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const ornamentPositions = [];

        // å¯åŠ¨ç¨‹åº
        init();
        animate();

        function init() {
            // 1. åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            scene.background = new THREE.Color(0x110011);

            // 2. ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 35);

            // 3. æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. æ§åˆ¶å™¨
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 + 0.1; 
            controls.minDistance = 10;
            controls.maxDistance = 60;

            // 5. ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffd700, 1.5, 100);
            pointLight.position.set(10, 20, 10);
            pointLight.castShadow = true;
            scene.add(pointLight);

            // 6. åˆ›å»ºç‰©ä½“
            createEnvironment();
            createTree();
            
            // 7. åŠ è½½å›¾ç‰‡
            if (myImages.length > 0) {
                setTimeout(loadPresetImages, 500);
            }

            // 8. ç›‘å¬äº‹ä»¶
            window.addEventListener('resize', onWindowResize);
            document.getElementById('file-input').addEventListener('change', handleFileUpload);
            renderer.domElement.addEventListener('click', onMouseClick);
            document.getElementById('close-modal').addEventListener('click', closeModal);
        }

        function createEnvironment() {
            // åœ°é¢
            const planeGeometry = new THREE.PlaneGeometry(200, 200);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xddddff, roughness: 1 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -1;
            plane.receiveShadow = true;
            scene.add(plane);

            // é›ªèŠ± - ä¿®å¤åçš„é€»è¾‘
            const particleCount = 1500;
            const particlesGeometry = new THREE.BufferGeometry();
            const posArray = new Float32Array(particleCount * 3);
            for(let i=0; i<particleCount * 3; i++) {
                posArray[i] = (Math.random() - 0.5) * 100;
            }
            particlesGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const particlesMaterial = new THREE.PointsMaterial({
                size: 0.2, 
                color: 0xffffff,
                transparent: true,
                opacity: 0.8
            });
            snowSystem = new THREE.Points(particlesGeometry, particlesMaterial);
            snowSystem.position.y = 20;
            scene.add(snowSystem);
        }

        function createTree() {
            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            // æ ‘å¹²
            const trunkGeometry = new THREE.CylinderGeometry(1.5, 2, 6, 12);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x4d2600, roughness: 0.8 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 2;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // æ ‘å¶
            const leafMaterial = new THREE.MeshStandardMaterial({ color: 0x0f5f13, roughness: 0.6, flatShading: true });
            const levels = [
                { height: 8, radius: 8, yPos: 7, positionsCount: 8 }, 
                { height: 7, radius: 6, yPos: 12, positionsCount: 6 }, 
                { height: 6, radius: 4, yPos: 16.5, positionsCount: 4 } 
            ];

            levels.forEach((level, index) => {
                const coneGeo = new THREE.ConeGeometry(level.radius, level.height, 16);
                const cone = new THREE.Mesh(coneGeo, leafMaterial);
                cone.position.y = level.yPos;
                cone.castShadow = true;
                treeGroup.add(cone);

                for (let i = 0; i < level.positionsCount; i++) {
                    const angle = (i / level.positionsCount) * Math.PI * 2;
                    const r = level.radius * 0.85; 
                    const x = Math.cos(angle) * r;
                    const y = level.yPos - level.height * 0.25; 
                    const z = Math.sin(angle) * r;
                    ornamentPositions.push({pos: new THREE.Vector3(x, y, z), angle: angle});
                }
            });

            // æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.OctahedronGeometry(1.5, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xffea00 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = 20;
            treeGroup.add(star);
            const starLight = new THREE.PointLight(0xffea00, 1, 20);
            starLight.position.set(0, 20.5, 0);
            treeGroup.add(starLight);
        }

        function loadPresetImages() {
            const textureLoader = new THREE.TextureLoader();
            myImages.forEach((imageName) => {
                if (ornaments.length >= ornamentPositions.length) return;
                textureLoader.load(
                    imageName, 
                    (texture) => { createPhotoFrame(texture, imageName); },
                    undefined,
                    (err) => { console.warn("æ— æ³•åŠ è½½é¢„è®¾å›¾ç‰‡:", imageName); }
                );
            });
        }

        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files.length) return;
            const textureLoader = new THREE.TextureLoader();

            Array.from(files).forEach(file => {
                if (ornaments.length >= ornamentPositions.length) {
                    alert("æ ‘ä¸ŠæŒ‚æ»¡å•¦ï¼");
                    return;
                }
                const reader = new FileReader();
                reader.onload = function(e) {
                    textureLoader.load(e.target.result, (texture) => {
                        createPhotoFrame(texture, e.target.result);
                    });
                };
                reader.readAsDataURL(file);
            });
            event.target.value = '';
        }

        function createPhotoFrame(texture, imageUri) {
            texture.colorSpace = THREE.SRGBColorSpace;
            const img = texture.image;
            let aspect = 1;
            if (img.width && img.height) aspect = img.width / img.height;

            let planeWidth = 2.5;
            let planeHeight = 2.5;
            if (aspect > 1) { planeHeight = planeWidth / aspect; } 
            else { planeWidth = planeHeight * aspect; }

            const frameGroup = new THREE.Group();
            const photoGeometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const photoMaterial = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
            const photoMesh = new THREE.Mesh(photoGeometry, photoMaterial);
            photoMesh.position.z = 0.05; 
            photoMesh.userData = { isPhoto: true, imageUri: imageUri };
            
            const borderGeometry = new THREE.PlaneGeometry(planeWidth + 0.2, planeHeight + 0.2);
            const borderMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
            const borderMesh = new THREE.Mesh(borderGeometry, borderMaterial);

            frameGroup.add(borderMesh);
            frameGroup.add(photoMesh);

            const posData = ornamentPositions[ornaments.length];
            frameGroup.position.copy(posData.pos);
            frameGroup.rotation.y = -posData.angle + Math.PI / 2;
            frameGroup.rotation.x = (Math.random() - 0.5) * 0.3;
            frameGroup.rotation.z = (Math.random() - 0.5) * 0.3;

            treeGroup.add(frameGroup);
            ornaments.push(photoMesh); 
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(ornaments);
            if (intersects.length > 0) {
                const selectedObject = intersects[0].object;
                if (selectedObject.userData.isPhoto) {
                    openModal(selectedObject.userData.imageUri);
                }
            }
        }

        function openModal(imageUri) {
            const modal = document.getElementById('image-modal');
            const modalImg = document.getElementById('modal-content');
            modalImg.src = imageUri;
            modal.style.display = 'flex';
        }
        function closeModal() { document.getElementById('image-modal').style.display = 'none'; }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // 1. æ—‹è½¬æ ‘
            if (treeGroup) treeGroup.rotation.y += 0.002;

            // 2. ä¸‹é›ªé€»è¾‘ (è¿™é‡Œé‡å†™äº†ï¼Œä¸ä¼šå†æŠ¥é”™äº†)
            if (snowSystem && snowSystem.geometry) {
                const positions = snowSystem.geometry.attributes.position.array;
                for(let i = 1; i < positions.length; i+=3) {
                    positions[i] -= 0.1; // ä¸‹è½é€Ÿåº¦
                    if (positions[i] < -20) positions[i] = 50; // è½åœ°åå›åˆ°ç©ºä¸­
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
